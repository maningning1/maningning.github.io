# I/O

> 本文为学习笔记，主要来自：[Java IO - 分类(传输，操作) | Java 全栈知识体系 (pdai.tech)](https://pdai.tech/md/java/io/java-io-basic-category.html)

## I/O分类

### 从传输方式上

从数据传输方式上可以将IO分为字节流和字符流，其中字节是给计算机看的，字符是给人看的，他们的区别主要在于：

+ 字节流读取单个字节，字符流读取单个字符（单个字符根据编码的不同，对应的字节数也不同，如UTF-8编码对应3个字节，中文编码对应2个字节）；
+ 字节流用于处理二进制文件（图片、音视频文件），字符流用来处理文本文件（使用某种编码，方便人阅读）；

### 从数据操作上

从数据操作的角度上，IO可以分为以下几种形式：

+ **文件**：FileInputStream、FileOutputStream、FileReader、FileWriter；
+ **数组**：
  + 字节数组：ByteArrayInputStream、ByteArrayOutputStream
  + 字符数组：CharArrayReader、CharArrayWriter；
+ **管道操作**：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter；
+ **基本数据类型**：DataInputStream、DataOutputStream；
+ **缓冲操作**：BufferedInputStream、BUfferedOutputStream、BufferedReader、BufferedWriter；
+ **打印**：PrintStream、PrintWriter；
+ **对象序列化**：ObjectInputStream、ObjectOutputStream；
+ **转换**：InputStreamReader、OutputStreamWriter；

## 实现

### InputStream

InputStream的类实现关系如下所示：

![1.01_InputStream类实现关系](C:\Users\18215\Desktop\io\1.01_InputStream类实现关系.png)

```java
// 读取数据
public abstract int read() 

// 将读取到的数据放在 byte 数组中，该方法实际上是根据下面的方法实现的，off 为 0，len 为数组的长度
public int read(byte b[]) 

// 从第 off 位置读取 len 长度字节的数据放到 byte 数组中，流是以 -1 来判断是否读取结束的
public int read(byte b[], int off, int len) 

// 跳过指定个数的字节不读取，如看电影跳过片头片尾
public long skip(long n) 

// 返回可读的字节数量
public int available() 

// 读取完，关闭流，释放资源
public void close() 

// 标记读取位置，下次还可以从这里开始读取，使用前要看当前流是否支持，可以使用 markSupport() 方法判断
public synchronized void mark(int readlimit) 

// 重置读取位置为上次 mark 标记的位置
public synchronized void reset() 

// 判断当前流是否支持标记流，和上面两个方法配套使用
public boolean markSupported() 
```

### OutputStream

OutputStream的类实现关系如下所示：

```java
// 写入一个字节，可以看到这里的参数是一个 int 类型，对应上面的读方法，int 类型的 32 位，只有低 8 位才写入，高 24 位将舍弃。
public abstract void write(int b)

// 将数组中的所有字节写入，和上面对应的 read() 方法类似，实际调用的也是下面的方法。
public void write(byte b[])

// 将 byte 数组从 off 位置开始，len 长度的字节写入
public void write(byte b[], int off, int len)

// 强制刷新，将缓冲中的数据写入
public void flush()

// 关闭输出流，流被关闭后就不能再输出数据了
public void close()
```

## 使用

### File相关

File类可以用于表示文件和目录的信息，但是它不表示文件的内容，如递归列出一个目录下所有文件：

```java
public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
```

### 字节流相关

```java
public static void copyFile(String src, String dist) throws IOException {

    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutputStream(dist);
    byte[] buffer = new byte[20 * 1024];

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while (in.read(buffer, 0, buffer.length) != -1) {
        out.write(buffer);
    }

    in.close();
    out.close();
}
```

实现逐行输出文本文件的内容：

```java
public static void readFileContent(String filePath) throws IOException {

    FileReader fileReader = new FileReader(filePath);
    BufferedReader bufferedReader = new BufferedReader(fileReader);

    String line;
    while ((line = bufferedReader.readLine()) != null) {
        System.out.println(line);
    }

    // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
    // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
    // 因此只要一个 close() 调用即可
    bufferedReader.close();
}
```

### 序列化

序列化就是将一个对象转换成字节序列，方便存储和传输，序列化不会对静态变量进行序列化，因为序列化只是保持对象的状态，静态变量属于类的状态。

**transient**关键字可以使一些属性不被序列化。

### 网络支持

+ InetAddress：用于表示网络上的硬件资源，即IP地址；
+ URL：统一资源定位符；
+ Sockets：使用TCP协议实现网络通信；
+ Datagram：使用UDP协议实现网络通信；

## Unix IO模型

一个输入操作通常分为两个阶段：

+ 等待数据准备好；
+ 从内核向进程复制数据；

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达，当所等待分组到达时，它被复制到内核中的某个缓冲区，第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

Unix下有五种I/O模型：

+ 阻塞式I/O；
+ 非阻塞式I/O；
+ I/O复用；
+ 信号驱动式I/O；
+ 异步I/O（AIO）；

### 阻塞式I/O

应用程序被阻塞，直到数据复制到应用进程缓冲区中才返回。

在阻塞过程中，其他程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞，因此不消耗CPU时间，执行效率较高。

![1.02_阻塞式io](C:\Users\18215\Desktop\io\1.02_阻塞式io.png)

### 非阻塞式I/O

应用进程执行系统调用后，内核返回一个错误码，应用进程可以继续执行，但是需要不断执行系统调用来获知I/O是否完成，即通过轮询不断尝试。

由于CPU要处理更多的系统调用，故该模型是比较低效的。

![1.03_非阻塞式io](C:\Users\18215\Desktop\io\1.03_非阻塞式io.png)

### I/O复用

使用select或者poll等待数据，并且可以等待多个套接字中任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回，之后再使用recvfrom把数据从内核复制到进程中。

如果没有I/O复用，则需要创建多个线程，I/O复用相对于多线程、多进程技术开销更小。

![1.04_io复用](C:\Users\18215\Desktop\io\1.04_io复用.png)

### 信号驱动I/O

应用进程使用sigaction系统调用，内核立即返回，应用程序可以继续执行，也就是说等待数据阶段应用进程是非阻塞的，内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中。

相比于非阻塞式I/O的轮询方式，信号驱动I/O的CPU利用率更高。

![1.05_信号驱动io](C:\Users\18215\Desktop\io\1.05_信号驱动io.png)

### 异步I/O

进行aio_read系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。

异步I/O与信号驱动I/O的区别在于：异步I/O的信号是通知应用进程I/O完成，而信号驱动I/O的信号是通知应用进程可以开始I/O。

![1.06_异步io](C:\Users\18215\Desktop\io\1.06_异步io.png)

### 比较

阻塞式I/O，非阻塞式I/O、I/O复用、信号驱动I/O都是同步I/O，即使在等待数据阶段不会阻塞，但是在之后将数据从内核复制到应用进程这个操作也会阻塞，异步I/O就不会阻塞。

![1.07_五种io比较](C:\Users\18215\Desktop\io\1.07_五种io比较.png)

## BIO

BIO就是blocking IO，最容易理解和实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面操作系统收到请求后，也会等待知道网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序收到数据，并解除等待状态。

### 传统BIO通讯方式

传统网络通信方式都是阻塞式的：

+ 客户端向服务端发出请求后，客户端会一直等待（不做其他事情），直到服务端返回结果或者网络出现问题；
+ 服务端在处理某个客户端发来的请求时，如果另一个客户端也发来请求时会等待，直到服务端这个处理线程完成上一个处理；

### 问题

同一时间服务端只能接受来自一个客户端的请求信息，并发性不足。所以针对此情况，提出了多线程技术来解决该问题：

+ 当服务端接收到客户端的请求后，将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端的请求；
+ 客户端也可以使用子线程和服务端进行通讯，这样客户端的主线程就可以不受影响进行其他工作了；

但是使用多线程来解决该问题也有一定的局限性：

+ 在服务端虽然请求的处理交给一个独立的线程进行，但是操作系统通知accept()的方式还是单个的，也就是说业务处理过程可以是多线程的，但是数据报文的接收还是需要一个一个的来；
+ 创建线程的数量是有限的，而且线程越多，CPU切换所需的时间也越长；
+ 创建线程非常消耗资源；

### BIO通信方式深入分析

