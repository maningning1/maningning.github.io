# Java并发编程-关键字

> 本文为学习笔记，主要参考：https://www.pdai.tech/md/java/thread/java-thread-x-key-synchronized.html

## synchronized关键字

### 作用

+ 原子性：原子性就是指一个操作或多个操作，要么全部执行且执行过程不会被任何因素打断，要么都不执行，被synchronized修饰的类或对象的所有操作都是原子的；
+ 可见性：可见性是指多个线程访问同一资源时，该资源的状态、值信息等对于其他线程都是可见的，synchronized和volatile都能保证可见性；
+ 有序性：有序性是指程序的执行顺序按照代码先后顺序执行，java运行编译器和处理器对指令进行重排，这样会影响多线程并发执行的顺序性，synchronized和volatile都能保证有序性；

### 使用

synchronized的使用有如下几种方式：

+ 对象锁：包括同步代码块锁和方法锁；

  + 同步代码块锁：手动指定锁定对象，也可以是this，也可以是自定义的锁：

    ```java
    synchronized (this) {
        // ...
    }
    
    Object block1 = new Object();
    synchronized (block1) {
        // ...
    }
    ```

  + synchronized修饰普通方法，锁对象默认为this：

    ```java
    public synchronized void method() {
        // ...
    }
    ```

+ 类锁：指synchronized修饰静态方法或者指定锁对象为Class对象；

  + 修饰静态方法：

    > 当synchronized修饰静态方法时，相当于锁的是当前所在的Class类，所以无论哪个线程访问它，需要的锁是一把，这时线程就会被锁住，而如果修饰的是普通方法，则相当于锁的是this对象，这样就是两把不同的锁，就不会有线程被锁住；

  ```java
  public class SynchronizedObjectLock implements Runnable {
      static SynchronizedObjectLock instence1 = new SynchronizedObjectLock();
      static SynchronizedObjectLock instence2 = new SynchronizedObjectLock();
  
      @Override
      public void run() {
          method();
      }
  
      // synchronized用在静态方法上，默认的锁就是当前所在的Class类，所以无论是哪个线程访问它，需要的锁都只有一把
      public static synchronized void method() {
          System.out.println("我是线程" + Thread.currentThread().getName());
          try {
              Thread.sleep(3000);
          } catch (InterruptedException e) {
              e.printStackTrace();
          }
          System.out.println(Thread.currentThread().getName() + "结束");
      }
  
      public static void main(String[] args) {
          Thread t1 = new Thread(instence1);
          Thread t2 = new Thread(instence2);
          t1.start();
          t2.start();
      }
  }
  ```

  + 修饰Class对象：

    ```java
    synchronized(XXXObject.class) {
        // ...
    }
    ```

### 原理

synchronized锁的代码段通过javac命令反编译之后可以看到在进入锁定代码段时会执行`monitorenter`指令，在离开锁定代码段时会执行`monitorexit`指令。

+ monitorenter指令：
  + monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，此时别的线程就需要等待该线程释放锁；
  + 如果这个monitor已经拿到该锁的所有权，又重入了这把锁，则锁计数器就会累加，变成2，并随着重入次数一直累加；
  + 这把锁已经被别的线程获取了，等待锁释放；
+ monitoresit指令：释放对于monitor的所有权，释放过程就是monitor的计数器减1，如果减完以后计数器不是0，则代表刚才是重入进来的，当前线程继续持有这把锁，如果计数器变为0，则释放锁；

### 可见性

synchronized的happends-before规则，即监视器锁规则：对同一个监视器的解锁，happends-before于对该监视器的加锁。

### JVM中锁的优化

JVM中monitorenter和monitorexit字节码依赖于底层操作系统的Mutex Lock来实现，这就需要将当前线程挂起并从用户态切换到内核态，这种切换的代价非常高，在jdk1.6中对锁进行了大量优化，引入了以下几种优化方式：

+ **锁粗化**：减少不必要的紧连在一起的unlock和lock，将多个连续的锁扩展成一个更大范围的锁；
+ **锁消除**：通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护，在栈上分配本身就是线程隔离的；
+ **偏向锁**：在无锁竞争的情况下避免执行不必要的CAS原子指令；
+ **适应性自旋**：当前线程在获取轻量级锁的过程中执行CAS操作失败时，在进入与monitor相关联的操作系统重量级锁前会进入忙等待然后再次尝试，当尝试一定次数后如果仍没有成功则调用互斥锁进入阻塞状态；

在jdk1.6以后，synchronized同步锁一共有一下四种状态，且锁可以升级但不能降级：

> 锁膨胀方向：无锁->偏向锁->轻量级锁->重量级锁

#### 锁与对象头

Java对象保存在内存中时，由对象头、实例数据、对齐填充字节组成，对象头又由Mark Word、指向类的指针、数组长度（只有数组对象才有）组成。

**Mark Word**

Mark Word在32位的JVM中长度为32bit，在64位JVM中长度是64bit，其在32位JVM中存储方式如下所示：

![1.04_JVM对象头](D:\study_note\maningning1.github.io\images\concurrent\1.04_JVM对象头.png)

+ 当没有被当成锁时，这就是个普通对象，记录对象的hash code，锁标志位为01，是否偏向锁为0；
+ 当对象被当做同步锁且线程A抢到了锁，锁标志位为01，是否偏向锁那一位变为1，前23bit记录抢到锁的线程id，进入偏向锁状态；
+ 当线程A再次试图获取锁时，发现是偏向状态，且线程id是它自己的id，则执行同步锁的代码；
+ 当线程B试图获取这个锁，锁此处处于偏向状态，且线程id不是线程B的id，那么线程B就会先用CAS试图获取锁，如果抢锁成功，则把Mark Word中的线程id改为线程B的id，代表线程B获得了这个偏向锁，否则继续下面的操作；
+ 如果偏向锁状态抢锁失败，偏向锁就会升级为轻量级锁，JVM会在当前线程的线程栈中开辟一块单独的空间，用于保存指向对象锁Mark Word的指针，同时在对象锁中保存指向这块空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行下面的操作；
+ 轻量级锁抢锁失败，JVM会使用自旋锁，如果自旋抢锁失败会继续执行下面的操作；
+ 如果自旋锁重试一定次数后失败，就会升级为重量级锁，锁标志位改为10；

#### 自旋锁

自旋也就是CAS，本质上与阻塞并不相同，如果锁占用的时间非常短，则自旋锁的性能会很好，如果锁占用的时间长，自旋会始终占用CPU的时间片，导致CPU资源被白白浪费，所以自旋等待的时间要有一定的限度，用户可以使用参数`-XX:PreBlockSpin`来更改。

#### 自适应自旋锁

为了提高性能，jdk1.6引入了自适应自旋锁，其意味着自旋的时间不再固定，自旋次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，比如在同一个锁对象上，自旋等待刚刚成功获取过锁，则认为自旋获取锁的概率大，会自适应增加自旋次数。

#### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程就会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程获得，不存在多线程竞争，就出现了偏向锁。

#### 轻量级锁

在代码进入同步块的时候，如果同步对象锁状态为无锁状态，进行以下几个步骤来获取锁：

+ JVM会先在当前线程的栈帧中建立一个名为锁对象（Lock Record）的空间，用于存储当前锁对象Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中；
+ 拷贝成功后，JVM将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word；
+ 如果整个更新动作成功了，那么这个线程就拥有了该对象的锁，且对象Mark Word的锁标志位设置为00，表示升级为轻量级锁；
+ 如果更新操作失败了，虚拟机会首先检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁；
+ 若当前只有一个等待线程，则该线程通过自旋进行等待，自旋超过一定次数，或者一个线程持有锁，另一个在自旋，有第三个线程来访时，升级为重量级锁；

#### 重量级锁

锁标志的状态值变为10，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

## volatile关键字

### 作用

#### 防重排序

在并发环境下单例实现方式：

```java
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```



#### 实现可见性



## final关键字

