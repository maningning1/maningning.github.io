# InnoDB查询优化

## Explain基本使用

对order_item_2020表进行explain命令，输出内容如下：

```mysql
explain select * from order_item_2020 where order_id=3057057080;
```

![4.01_explain输出](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.01_explain%E8%BE%93%E5%87%BA.png)

各个字段含义如下：

+ **id**：select查询的标识符，每个select都会自动分配一个唯一的标识符；
+ **select_type**：select查询的类型；
+ **table**：查询的是哪个表；
+ **partitions**：匹配的分区；
+ **type**：针对单表的访问方式；
+ **possible_keys**：此次查询中可能选用的索引；
+ **key**：此次查询中确切用到的索引；
+ **key_len**：实际使用的索引长度；
+ **ref**：当使用索引列等值查询时，与索引列进行等值匹配的对象信息；
+ **rows**：显示次查询一共扫描了多少行，这是一个估计值；
+ **filtered**：表示此条件所过滤数据的百分比；
+ **extra**：额外的信息；

## 单表访问方法

MySQL执行查询语句的方式称为**访问方法**或者**访问类型**，同一查询可以使用多种不同的方法方法来执行，其效率也是不同的，具体有如下几种访问方法：

### const

const是指查询为常数级别，代价非常低，是通过**主键索引**或者**唯一二级索引**来定位一条记录的访问方法。

+ 主键索引：直接利用主键值在聚簇索引中定位到用户记录（无需回表）；
+ 唯一二级索引：仅需一次回表操作；

> 例外：当唯一二级索引的搜索条件为NULL时，这个语句便不可以使用const访问方式。

### ref

ref是指将某个普通二级索引与常数进行等值比较，因为二级索引并不限制索引列的唯一值，所以二级索引的记录可能有多条，此时就需要进行多次回表操作，同理唯一二级索引的搜索条件为NULL时，也是这种情况。

```mysql
select * from order_item_2020 where order_id=3057057080;
```

### ref_or_null

ref_or_null是指除了找出某个二级索引列的值等于某个常数记录外，还想把NULL的记录也找出来。

```mysql
select * from order_item_2020 where order_id=3057057080 or order_id is null;
```

### range

range是指使用索引执行查询时，对应的扫描区间为若干了单点扫描区间或者范围扫描区间，且扫描区间范围不能是（-∞, +∞）。

```mysql
select * from order_item_2020 where order_id in (3057057080, 3056950082);
```

### index

index需要满足如下两个条件：

+ 查询条件是联合索引中不是最左边的列，这样就不能使用ref或者range执行方法来执行；
+ 搜索的列只有联合索引包含的列，这样虽然扫描区间是（-∞, +∞），但是不用做回表操作；

> 全表扫描中添加“order by 主键”的语句也是被认定使用的是index执行方法。

### all

all就是全表扫描，直接扫描所有的聚簇索引记录。

### 注意事项

#### 索引合并

MySQL在一般情况下只会为单个索引生成扫描区间，在特殊情况下也可能为多个索引生成扫描区间，这种使用多个索引来完成一次查询的执行方法称为**索引合并（index merge）**。

+ **Intersection索引合并**

  比如有执行全表两个普通索引的查询如下：

  ```mysql
  select * from tableXXX where key1 = xxx and key2 = xxx;
  ```

  Intersection索引合并是指对key1和key2同时执行各自索引查询，将结果取交集再回表操作，如果不使用Intersection索引合并的方式则是先通过key1查询，然后进行回表操作再筛选出与key2匹配的列。

  如果key1扫描区间的二级索引记录和key2扫描区间的二级索引记录是按照主键值顺序排序的，才会采用Intersection索引合并的方式。

+ **Union索引合并**

  比如有执行全表两个普通索引的查询如下：

  ```mysql
  select * from tableXXX where key1 = xxx or key2 = xxx;
  ```

  Union索引合并是指对key1和key2同时执行各自索引查询，将结果取并集再回表操作，如果不使用Union索引合并的方式则是不管使用key1还是key2，均是全表查询。

  如果key1扫描区间的二级索引记录和key2扫描区间的二级索引记录是按照主键值顺序排序的，才会采用Union索引合并的方式。

+ **Sort-Union索引合并**

  Union索引合并的条件太苛刻了，所以推出了Sort-Union索引合并的方式：先将从各个索引中扫描到的记录的主键进行排序，在按照执行Union索引合并的方式执行查询。

## 连接

### 简介

连接从本质上来说就是将各个表中的记录都取出来进行依次匹配，并把匹配后的组合发送给客户端，如下图所示：

```mysql
select * from t1, t2;
```

![4.02_连接](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.02_%E8%BF%9E%E6%8E%A5.png)

如果没有查询条件，连接产生的笛卡尔积就会很大，所以可以指定一些过滤条件，连接查询的执行过程如下所示：

+ 1、确定第一个需要查询的表，这个表称为驱动表；
+ 2、从驱动表中获取到的一条记录，都需要去第2张表中查找匹配的记录；

在两表连接查询中，驱动表只需要访问一次，被驱动表可能需要访问多次。

除了内连接，还有外连接，这里就不介绍了。

### 原理

对于两表连接来说，驱动表只会被访问一次，而被驱动表会访问多次。对于内连接来说，选取哪个表作为驱动表都没关系，对于外连接的驱动表就是固定的，左连接的驱动表就是左边那个表，右连接的驱动表就是右边那个表。

所以多表连接原理相当于多个单表查询，比如对于如下语句：

```mysql
select * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
```

![4.03_连接查询](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.03_%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png)

查询完t1后结果集有2条记录，然后查询t2相当于执行了2次：

```mysql
# t1.m1=2
select * from t2 where t2.m2 = 2 and t2.n2 < 'd';
# t1.m1=3
select * from t2 where t2.m2 = 3 and t2.n2 < 'd';
```

### Join Buffer

连接查询时，被驱动表会被访问多次，如果数据太多就可能会导致前面记录的内存被释放掉，所以MySQL提出了**Join Buffer（连接缓冲区）**的概念，在执行连接查询前申请一块固定大小的内存，先把驱动表的结果集放入Join Buffer中，然后扫描被驱动表。

## 基于成本优化

### 成本的概念

MySQL在执行一个查询时可以由不同的执行方案，它会选择其中成本最低的方案去真正地执行，MySQL中一条查询语句的执行成本由两个方面组成：

+ **I/O成本**：把数据从磁盘加载到内存的损耗时间称为I/O成本；
+ **CPU成本**：读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序等操作损耗的时间称为CPU成本；

### 单表查询的成本

在真正执行一条单表查询语句之前，MySQL优化器会找出所有可以用来执行该语句的方案，并在对比这些方案之后找出成本最低的方案，这就是所谓的执行计划，之后才会调用存储引擎提供的接口真正地执行查询。

这个过程主要有如下四个步骤：

+ **1、根据搜索条件，找出所有可能使用的索引**

  对于B+树索引来说，只要索引列和常数使用=、<=>、in、not in、is null、is not null、>、<、>=、<=、between、!=、或者like，就会产生一个扫描区间，那么这些搜索条件就会用到索引，则需要首先找出所有可能使用的索引。

+ **2、计算全表扫描的代价**

  对于InnoDB存储引擎来说，计算全表扫描也就是需要将聚簇索引所对应的页面都加载到内存，所以计算全表扫描的代价也就是需要计算聚簇索引占用的页面数和表中的记录数，来计算其I/O成本和CPU成本。

  MySQL提供了如下语句可以查看表的统计信息：

  ```mysql
  show table status like 'order_item_2020';
  ```

  ![4.04_统计信息查询](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.04_%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2.png)

  + Rows：表示表中的记录数，对于MyISAM该值是准确的，对于InnoDB该值是个估计值；
  + Data_length：表示表占用的存储空间字节数，对于MyISAM该值就是数据文件的大小，对于InnoDB该值就相当于聚簇索引占用存储空间的大小，也就是该值等于：`Data_length = 聚簇索引的页面数量 X 每个页面的大小`，这样就可以反推页面数量；

  通过以上数据就可以对全表扫描的代价进行计算：

  + I/O成本：`I/O成本 = 聚簇索引的页面数量 X 1.0 + 1.1`
  + CPU成本：`CPU成本 = 记录数 X 0.2 + 1.0`
  + 总成本：`总成本 = I/O成本 + CPU成本`

  > 对于I/O成本计算计算，1.0代表加载一个页面的成本常数，1.1是MySQL自定义的微调值；
  >
  > 对于CPU成本计算，0.2代表访问一条计算所需的成本常数，1.0是MySQL自定义的微调值；

+ **3、计算使用不同索引执行查询的代价**

  对于一个查询可能会使用到多个索引，MySQL查询优化器会先分析使用唯一二级索引的成本，再分析普通索引的成本，并还要分析是否使用到了索引合并。

  对于使用二级索引+回表方式执行的查询，计算查询成本时依赖于扫描区间数量和需要回表的记录数两方面数据：

  + 扫描区间数量

    无论扫描区间的二级索引到底占用了多少个页面，查询优化器均认为其I/O成本与读取一个页面的I/O成本时相同的，故I/O成本为`1 X 1.0`；

  + 需要回表的记录数

    根据扫描区间在二级索引的B+树中找到最左和最右的记录，如果记录在一个页面中就直接得出记录的条数（也就是回表的记录数），如果跨多个页面可以通过索引页中Page Header中的PAGE_N_RECS得到页中的记录数，从而进行计算得出；

+ **4、对比各种执行方案的代价，找出成本最低的那个方案**

  将全表扫描代价和使用不同索引执行查询的代价做对比，选择成本最低的执行查询。

### 连接查询的成本

根据前文提到的，在MySQL中连接查询采用的是嵌套循环连接算法，也就是驱动表会被访问一次，被驱动表可能会被访问多次，所以它的查询成本由两部分组成：

+ 单词查询驱动表的成本；
+ 多次查询被驱动表的成本；

把查询驱动表后得到的记录数称为驱动表的**扇出（fanout）**，驱动表的扇出值越小，对被驱动表的查询次数也越少，连接查询的总成本也越低，不过在以下两种情况计算驱动表扇出值时需要猜测：

+ 如果使用全表扫描的方式执行单表查询，计算驱动表扇出值时需要猜测满足全部搜索条件的记录到底有多少条；
+ 如果使用索引来执行单表查询，那么计算驱动表扇出值时需要猜测除了满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条；

所以两表联系查询的成本计算公式如下：

```
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出值 X 单次访问被驱动表的成本
```

对于外连接查询驱动表是固定的，对于内连接查询驱动表和被驱动表位置是可以互换的，则需要考虑最优的表连接顺序。

## 基于规则优化

MySQL可以依据一些规则，将一些糟糕的语句转化为某种可以高效执行的形式，这个过程称为查询重写。

### 条件化简

+ **移除不必要的括号**

  优化器会把语句中不必要的括号移除掉：

  ```mysql
  # 优化前
  select * from (t1, (t2, t3)) where t1.a=t2.a and t2.b=t3.b;
  # 优化后
  select * from t1, t2, t3 where t1.a=t2.a and t2.b=t3.b;
  ```

+ **常量传递**

  当涉及某个列与常量的等值匹配，且使用and操作符将其他涉及该列的表达式连接起来是：

  ```mysql
  # 优化前
  select * from t1 where a = 5 and b > a;
  # 优化后
  select * from t1 where a = 5 and b > 5;
  ```

+ **移除没用的条件**

  一些永远为true或者永远为false的表达式将会被移除：

  ```mysql
  # 优化前
  select * from t1 where (a < 1 and b = b) or (a = 6 or 5 != 5);
  # 优化后
  select * from t1 where a < 1 or a = 6;
  ```

+ **表达式计算**

  如果表达式包含常量的话其值会被先计算出来：

  ```mysql
  # 优化前
  select * from t1 where a = 5 + 1;
  # 优化后
  select * from t1 where a = 6;
  ```

  > 如果某个列不是以单独的形式作为表达式的操作数，则不会优化，如-a < -8，所以最好让索引列以单独的形式出现在搜索条件的表达式中。

+ **having子句和where子句合并**

  如果查询语句中没有出现诸如sum、max这样的聚集函数以及group by子句，查询优化器就会将having子句和where子句合并起来。

+ **常量表检测**

  MySQL任务const的单表查询时间很短，所以会将const级别的查询出来，然后对语句进行转换。

### 外连接消除

在外连接查询中，指定的where子句中包含被驱动表的列不为null，外连接和内连接就可以相互转换了。

### 子查询优化

#### 子查询

#### 优化

## Explain详解

