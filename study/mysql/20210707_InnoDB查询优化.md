# InnoDB查询优化

## 单表访问方法

MySQL执行查询语句的方式称为**访问方法**或者**访问类型**，同一查询可以使用多种不同的方法方法来执行，其效率也是不同的，具体有如下几种访问方法：

### const

const是指查询为常数级别，代价非常低，是通过**主键索引**或者**唯一二级索引**来定位一条记录的访问方法。

+ 主键索引：直接利用主键值在聚簇索引中定位到用户记录（无需回表）；
+ 唯一二级索引：仅需一次回表操作；

> 例外：当唯一二级索引的搜索条件为NULL时，这个语句便不可以使用const访问方式。

### ref

ref是指将某个普通二级索引与常数进行等值比较，因为二级索引并不限制索引列的唯一值，所以二级索引的记录可能有多条，此时就需要进行多次回表操作，同理唯一二级索引的搜索条件为NULL时，也是这种情况。

```mysql
select * from order_item_2020 where order_id=3057057080;
```

### ref_or_null

ref_or_null是指除了找出某个二级索引列的值等于某个常数记录外，还想把NULL的记录也找出来。

```mysql
select * from order_item_2020 where order_id=3057057080 or order_id is null;
```

### range

range是指使用索引执行查询时，对应的扫描区间为若干了单点扫描区间或者范围扫描区间，且扫描区间范围不能是（-∞, +∞）。

```mysql
select * from order_item_2020 where order_id in (3057057080, 3056950082);
```

### index

index需要满足如下两个条件：

+ 查询条件是联合索引中不是最左边的列，这样就不能使用ref或者range执行方法来执行；
+ 搜索的列只有联合索引包含的列，这样虽然扫描区间是（-∞, +∞），但是不用做回表操作；

> 全表扫描中添加“order by 主键”的语句也是被认定使用的是index执行方法。

### all

all就是全表扫描，直接扫描所有的聚簇索引记录。

### 注意事项

#### 索引合并

MySQL在一般情况下只会为单个索引生成扫描区间，在特殊情况下也可能为多个索引生成扫描区间，这种使用多个索引来完成一次查询的执行方法称为**索引合并（index merge）**。

+ **Intersection索引合并**

  比如有执行全表两个普通索引的查询如下：

  ```mysql
  select * from tableXXX where key1 = xxx and key2 = xxx;
  ```

  Intersection索引合并是指对key1和key2同时执行各自索引查询，将结果取交集再回表操作，如果不使用Intersection索引合并的方式则是先通过key1查询，然后进行回表操作再筛选出与key2匹配的列。

  如果key1扫描区间的二级索引记录和key2扫描区间的二级索引记录是按照主键值顺序排序的，才会采用Intersection索引合并的方式。

+ **Union索引合并**

  比如有执行全表两个普通索引的查询如下：

  ```mysql
  select * from tableXXX where key1 = xxx or key2 = xxx;
  ```

  Union索引合并是指对key1和key2同时执行各自索引查询，将结果取并集再回表操作，如果不使用Union索引合并的方式则是不管使用key1还是key2，均是全表查询。

  如果key1扫描区间的二级索引记录和key2扫描区间的二级索引记录是按照主键值顺序排序的，才会采用Union索引合并的方式。

+ **Sort-Union索引合并**

  Union索引合并的条件太苛刻了，所以推出了Sort-Union索引合并的方式：先将从各个索引中扫描到的记录的主键进行排序，在按照执行Union索引合并的方式执行查询。

## 连接

### 简介

连接从本质上来说就是将各个表中的记录都取出来进行依次匹配，并把匹配后的组合发送给客户端，如下图所示：

```mysql
select * from t1, t2;
```

![4.02_连接](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.02_%E8%BF%9E%E6%8E%A5.png)

如果没有查询条件，连接产生的笛卡尔积就会很大，所以可以指定一些过滤条件，连接查询的执行过程如下所示：

+ 1、确定第一个需要查询的表，这个表称为驱动表；
+ 2、从驱动表中获取到的一条记录，都需要去第2张表中查找匹配的记录；

在两表连接查询中，驱动表只需要访问一次，被驱动表可能需要访问多次。

除了内连接，还有外连接，这里就不介绍了。

### 原理

对于两表连接来说，驱动表只会被访问一次，而被驱动表会访问多次。对于内连接来说，选取哪个表作为驱动表都没关系，对于外连接的驱动表就是固定的，左连接的驱动表就是左边那个表，右连接的驱动表就是右边那个表。

所以多表连接原理相当于多个单表查询，比如对于如下语句：

```mysql
select * from t1, t2 where t1.m1 > 1 and t1.m1 = t2.m2 and t2.n2 < 'd';
```

![](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.03_%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2.png)

查询完t1后结果集有2条记录，然后查询t2相当于执行了2次：

```mysql
# t1.m1=2
select * from t2 where t2.m2 = 2 and t2.n2 < 'd';
# t1.m1=3
select * from t2 where t2.m2 = 3 and t2.n2 < 'd';
```

### Join Buffer

连接查询时，被驱动表会被访问多次，如果数据太多就可能会导致前面记录的内存被释放掉，所以MySQL提出了**Join Buffer（连接缓冲区）**的概念，在执行连接查询前申请一块固定大小的内存，先把驱动表的结果集放入Join Buffer中，然后扫描被驱动表。

## 基于成本优化

### 成本的概念

MySQL在执行一个查询时可以由不同的执行方案，它会选择其中成本最低的方案去真正地执行，MySQL中一条查询语句的执行成本由两个方面组成：

+ **I/O成本**：把数据从磁盘加载到内存的损耗时间称为I/O成本；
+ **CPU成本**：读取记录以及检测记录是否满足对应的搜索条件、对结果集进行排序等操作损耗的时间称为CPU成本；

### 单表查询的成本

在真正执行一条单表查询语句之前，MySQL优化器会找出所有可以用来执行该语句的方案，并在对比这些方案之后找出成本最低的方案，这就是所谓的执行计划，之后才会调用存储引擎提供的接口真正地执行查询。

这个过程主要有如下四个步骤：

+ **1、根据搜索条件，找出所有可能使用的索引**

  对于B+树索引来说，只要索引列和常数使用=、<=>、in、not in、is null、is not null、>、<、>=、<=、between、!=、或者like，就会产生一个扫描区间，那么这些搜索条件就会用到索引，则需要首先找出所有可能使用的索引。

+ **2、计算全表扫描的代价**

  对于InnoDB存储引擎来说，计算全表扫描也就是需要将聚簇索引所对应的页面都加载到内存，所以计算全表扫描的代价也就是需要计算聚簇索引占用的页面数和表中的记录数，来计算其I/O成本和CPU成本。

  MySQL提供了如下语句可以查看表的统计信息：

  ```mysql
  show table status like 'order_item_2020';
  ```

  ![4.04_统计信息查询](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.04_%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2.png)

  + Rows：表示表中的记录数，对于MyISAM该值是准确的，对于InnoDB该值是个估计值；
  + Data_length：表示表占用的存储空间字节数，对于MyISAM该值就是数据文件的大小，对于InnoDB该值就相当于聚簇索引占用存储空间的大小，也就是该值等于：`Data_length = 聚簇索引的页面数量 X 每个页面的大小`，这样就可以反推页面数量；

  通过以上数据就可以对全表扫描的代价进行计算：

  + I/O成本：`I/O成本 = 聚簇索引的页面数量 X 1.0 + 1.1`
  + CPU成本：`CPU成本 = 记录数 X 0.2 + 1.0`
  + 总成本：`总成本 = I/O成本 + CPU成本`

  > 对于I/O成本计算计算，1.0代表加载一个页面的成本常数，1.1是MySQL自定义的微调值；
  >
  > 对于CPU成本计算，0.2代表访问一条计算所需的成本常数，1.0是MySQL自定义的微调值；

+ **3、计算使用不同索引执行查询的代价**

  对于一个查询可能会使用到多个索引，MySQL查询优化器会先分析使用唯一二级索引的成本，再分析普通索引的成本，并还要分析是否使用到了索引合并。

  对于使用二级索引+回表方式执行的查询，计算查询成本时依赖于扫描区间数量和需要回表的记录数两方面数据：

  + 扫描区间数量

    无论扫描区间的二级索引到底占用了多少个页面，查询优化器均认为其I/O成本与读取一个页面的I/O成本时相同的，故I/O成本为`1 X 1.0`；

  + 需要回表的记录数

    根据扫描区间在二级索引的B+树中找到最左和最右的记录，如果记录在一个页面中就直接得出记录的条数（也就是回表的记录数），如果跨多个页面可以通过索引页中Page Header中的PAGE_N_RECS得到页中的记录数，从而进行计算得出；

+ **4、对比各种执行方案的代价，找出成本最低的那个方案**

  将全表扫描代价和使用不同索引执行查询的代价做对比，选择成本最低的执行查询。

### 连接查询的成本

根据前文提到的，在MySQL中连接查询采用的是嵌套循环连接算法，也就是驱动表会被访问一次，被驱动表可能会被访问多次，所以它的查询成本由两部分组成：

+ 单词查询驱动表的成本；
+ 多次查询被驱动表的成本；

把查询驱动表后得到的记录数称为驱动表的**扇出（fanout）**，驱动表的扇出值越小，对被驱动表的查询次数也越少，连接查询的总成本也越低，不过在以下两种情况计算驱动表扇出值时需要猜测：

+ 如果使用全表扫描的方式执行单表查询，计算驱动表扇出值时需要猜测满足全部搜索条件的记录到底有多少条；
+ 如果使用索引来执行单表查询，那么计算驱动表扇出值时需要猜测除了满足形成索引扫描区间的搜索条件外，还满足其他搜索条件的记录有多少条；

所以两表联系查询的成本计算公式如下：

```
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出值 X 单次访问被驱动表的成本
```

对于外连接查询驱动表是固定的，对于内连接查询驱动表和被驱动表位置是可以互换的，则需要考虑最优的表连接顺序。

## 基于规则优化

MySQL可以依据一些规则，将一些糟糕的语句转化为某种可以高效执行的形式，这个过程称为查询重写。

### 条件化简

+ **移除不必要的括号**

  优化器会把语句中不必要的括号移除掉：

  ```mysql
  # 优化前
  select * from (t1, (t2, t3)) where t1.a=t2.a and t2.b=t3.b;
  # 优化后
  select * from t1, t2, t3 where t1.a=t2.a and t2.b=t3.b;
  ```

+ **常量传递**

  当涉及某个列与常量的等值匹配，且使用and操作符将其他涉及该列的表达式连接起来是：

  ```mysql
  # 优化前
  select * from t1 where a = 5 and b > a;
  # 优化后
  select * from t1 where a = 5 and b > 5;
  ```

+ **移除没用的条件**

  一些永远为true或者永远为false的表达式将会被移除：

  ```mysql
  # 优化前
  select * from t1 where (a < 1 and b = b) or (a = 6 or 5 != 5);
  # 优化后
  select * from t1 where a < 1 or a = 6;
  ```

+ **表达式计算**

  如果表达式包含常量的话其值会被先计算出来：

  ```mysql
  # 优化前
  select * from t1 where a = 5 + 1;
  # 优化后
  select * from t1 where a = 6;
  ```

  > 如果某个列不是以单独的形式作为表达式的操作数，则不会优化，如-a < -8，所以最好让索引列以单独的形式出现在搜索条件的表达式中。

+ **having子句和where子句合并**

  如果查询语句中没有出现诸如sum、max这样的聚集函数以及group by子句，查询优化器就会将having子句和where子句合并起来。

+ **常量表检测**

  MySQL任务const的单表查询时间很短，所以会将const级别的查询出来，然后对语句进行转换。

### 外连接消除

在外连接查询中，指定的where子句中包含被驱动表的列不为null，外连接和内连接就可以相互转换了。

### 子查询优化

#### 子查询

子查询语法如下所示：

```mysql
select m, n from (select m2 + 1 as m, n2 as n from t2 where m2 > 2) as t;
```

子查询出现在了from子句中，这里子查询相当于一个名称为t的表，t中有m和n两列，这种放在from子句后面的子查询称为派生表。子查询可以通过一下两点进行分类：

+ **1、按返回的结果集区分子查询**

  + 标量子查询：查询语句中子查询都返回一个单一的值（也就是一个标量）；

    ```mysql
    select (select m1 from t1 limit 1);
    ```

  + 行子查询：返回一条记录的子查询，不过这条记录需要包含多个列，如果只包含一个列，则是标量子查询；

    ```mysql
    select * from t1 where (m1, n1) = (select m2, n2 from t2 limit 1); 
    ```

  + 列子查询：查出一个列的数据，不过这个列的数据需要包含多条记录，否则是标量子查询；

    ```mysql
    select * from t1 where m1 in (select m2 from t2);
    ```

  + 表子查询：子查询结果包含很多天记录，也包含很多列；

    ```mysql
    select * from t1 where (m1, n1) in (select m2, n2 from t2); 
    ```

+ **2、按与外层查询的关系来区分子查询**

  + 不相关子查询：如果子查询可以单独运行出结果，不依赖于外部查询的值，就是不相关子查询；

  + 相关子查询：子查询的执行需要依赖于外层查询的值，就是相关子查询；

    ```mysql
    select * from t1 where m1 in (select m2 from t2 where n1 = n2);
    ```

    其中n1是表t1的列。

+ **注意事项**

  + 子查询必须用小括号括起来；
  + select子句中的子查询必须是标量子查询；
  + 要想得到标量子查询或行子查询，使用limit 1做限制；
  + 对于[not] in/any/some/all子查询，不允许有limit；
  + 增删改中不允许出席子查询；

#### 优化

##### 标量子查询与行子查询的执行方式

+ 不相关子查询：

  ```mysql
  select * from s1 where key1 = (select key2 from s2 where key3 = 10 limit 1);
  ```

  + 1、单独执行子查询；
  + 2、将子查询得到的结果作为外层查询的参数；

+ 相关子查询：

  ```mysql
  select * from s1 where key1 = (select key2 from s2 where s1.key3 = s2.key3 limit 1);
  ```

  + 1、先从外层查询中获取一条记录，即s1表；
  + 2、从这条记录中找出子查询中涉及的值，执行子查询，即找出s1.key3的值；
  + 3、根据子查询的结果检测外层的where是否成立，如果成立加入结果集，否则丢弃；
  + 4、跳转至1，重复至外层查询获取不到记录；

##### in子查询优化

如果in子查询符合转化为半连接的条件，查询优化器会优先把该子查询转换为半连接，再考虑以下5种执行半连接的策略中哪个的成本最低，最后从中选择成本最低的执行策略来执行：

+ Table pullout
+ Duplicate Weedout
+ LooseScan
+ Semi-join Materialization
+ First Match execution

如果in子查询不符合转化为半连接的条件，则查询优化器会从下面两种策略中找出一种成本更低的方式来执行子查询：

+ 先将子查询物化，再执行查询；
+ 执行in到exists的转换；

##### any/all子查询优化

可以进行相应转换。

##### [not] exists子查询优化

如果[not] exists子查询是不相关子查询，可以先执行子查询，得出查询结果是true还是false，然后重写原先的查询语句。

##### 派生表的优化

+ 派生表物化；
+ 将派生表和外层查询合并；

## Explain详解

### 简介

通过前面优化原理等知识，对Explain详解，其基本使用如下所示（以order_item_2020为例）：

```mysql
explain select * from order_item_2020 where order_id=3057057080;
```

![4.01_explain输出](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.01_explain%E8%BE%93%E5%87%BA.png)

各个字段含义如下：

+ **id**：select查询的标识符，每个select都会自动分配一个唯一的标识符；
+ **select_type**：select查询的类型；
+ **table**：查询的是哪个表；
+ **partitions**：匹配的分区；
+ **type**：针对单表的访问方式；
+ **possible_keys**：此次查询中可能选用的索引；
+ **key**：此次查询中确切用到的索引；
+ **key_len**：实际使用的索引长度；
+ **ref**：当使用索引列等值查询时，与索引列进行等值匹配的对象信息；
+ **rows**：显示次查询一共扫描了多少行，这是一个估计值；
+ **filtered**：表示此条件所过滤数据的百分比；
+ **extra**：额外的信息；

### table

无论查询语句多复杂，包含多少个表，到最后都是对每个表进行单表访问，比如联合查询如下所示：

```mysql
explain select * from order_master_2020 inner join order_item_2020;
```

![4.05_explain_table](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.05_explain_table.png)

### id

id是用来针对没出现一个select关键字，就分配一个id值。

+ 对于连接查询，from后面可以跟随多个表，每个表会对应一条记录，但是这些记录的id值是相同的，如上图4.05所示；

+ 对于包含子查询的语句来说，就涉及多个select关键字，如下所示：

  ```mysql
  explain select * from order_master_2020 where order_id = (select order_id from order_item_2020 where id = 3057057080); 
  ```

  ![4.06_explain_id_子查询](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.06_explain_id_%E5%AD%90%E6%9F%A5%E8%AF%A2.png)

+ 对于包含union子句的查询语句，它会把多个子查询的结果集并起来并去重，所以就会在内部创建一张临时表，如下所示：

  ```mysql
  explain select order_id from order_master_2020 union select order_id from order_item_2020;
  ```

  ![4.07_explain_union](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.07_explain_union.png)

  而对于union all就不需要对最终结果集去重，所以就没有使用到临时表，如下所示：

  ```mysql
  explain select order_id from order_master_2020 union all select order_id from order_item_2020;
  ```

  ![4.08_explain_union_all](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.08_explain_union_all.png)

### select_type

一个大查询中可以包含多个select关键字，也可以在from子句中包含多张表，select_type用于标识每个小查询的类型，其有如下几个属性：

+ **SIMPLE**：查询语句中不包含UNION或者子查询的查询都算作SIMPLE类型；

+ **PRIMARY**：对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边那个查询的select_type就是PRIMARY，如上图4.06所示；

+ **UNION**：对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，除了最左边那个小查询之外，其余小查询的select_type都是UNION；

+ **UNION RESULT**：MySQL选择临时表来完成union的查询去重工作，这个临时表的select_type就是UNION RESULT，如上图4.07所示；

+ **SUBQUERY**：如果包含子查询的查询语句不能够转为对应的半连接形式，并且该子查询是不相关子查询，而且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的select_type就是SUBQUERY；

+ **DEPENDENT SUBQUERY**：如果包含子查询的查询语句不能转为对应的半连接形式，且该子查询被查询优化器转换为相关子查询的形式，则该子查询的第一个select关键字代表的那个查询的select_type就是DEPENDENT SUBQUERY；

+ **DEPENDENT UNION**：在包含union或者union all的大查询中，如果各个小查询都依赖于外层查询，则除了最左边的那个小查询外，其他的小查询的select_type值就是DEPENDENT UNION；

+ **DERIVED**：在包含派生表的查询中，如果是以物化派生表的方式执行查询，则派生表对应的子查询的select_type就是DERIVED，如下所示：

  ```mysql
  explain select * from (select order_id, count(*) as c from order_item_2020 group by order_id) as derived where c > 1;
  ```

  ![4.09_explain_derived](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.09_explain_derived.png)

+ **MATERIALIZED**：当查询优化器在执行包含子查询的语句时，选择将子查询物化后与外层查询进行连接查询，该子查询对应的select_type就是MATERIALIZED；

### type

type列表明了这个访问方法是什么，其有如下几种访问方法：

+ **system**：当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的；

+ **const**：主键或唯一二级索引；

+ **eq_ref**：连接查询时，被驱动表通过主键或者不允许为null的唯一二级索引进行等值匹配方式进行访问，如下所示：

  ```mysql
  explain select * from order_master_2020 inner join order_item_2020 where order_master_2020.order_id = order_item_2020.order_id;
  ```

  ![4.10_explain_type_eq_ref](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.10_explain_type_eq_ref.png)

+ **ref**：普通二级索引列与常量等值匹配；
+ **fulltext**：全文索引；
+ **ref_or_not**：普通二级索引等值匹配，且该值可以为null；
+ **index_merge**：索引合并；
+ **unique_subquery**：针对包含in子查询的查询语句，查询优化器将in转换为exists子查询，且子查询转换后可以使用主键或不允许为null值的唯一二级索引；
+ **index_subquery**：与unique_subquery类似，使用的是普通索引；
+ **range**：使用索引对范围查询；
+ **index**：使用索引覆盖；
+ **all**：全表扫描；

### possible_keys&&key

possible_keys表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，key表示实际用到的索引有哪些。

```mysql
explain select * from order_item_2020 where order_id = 3056543443 and create_time > '2021-05-20 19:42:16';
```

![4.11_explain_keys](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.11_explain_keys.png)

> Tips：possible_keys并不是越多越好，可以使用的索引越多，查询优化器计算查询成本花费的时间越长，所以尽量删除那些用不到的索引。

### key_len

使用索引长度，其由以下3个部分组成：

+ 该列的实际数据最多占用的存储空间长度；
  + 对于固定长度类型来说，如int类型，其值就是4字节；
  + 对于变长类型，如使用utf8字符集，类型为varchar(100)的列，该列的实际数据最多占用字节数为3*100=300字节；
+ 如果该列可以存储null值，则该列的实际数据加1；
+ 如果是变长类型，会有2字节空间存储实际数据，所以加2；

```mysql
explain select * from order_item_2020 where order_id = 3056543443;
```

![4.12_explain_key_len_int](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.12_explain_key_len_int.png)

对于上图，order_id类型为long，且非空，故key_len为8；

```mysql
explain select * from supplier_p2p_order_2020 where supplier_order_id = '20210621023698_0001';
```

![4.13_explain_key_len_varchar](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.13_explain_key_len_varchar.png)

对于上图，supplier_order_id类型为varchar(64)，字符集为utf8mb4_general_ci，故存储空间长度占用为64*4=256，且该值变长且不非空，故其值为259。

### ref

当访问方法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery其中一个时，ref列展示的就是与索引列进行等值匹配的是什么，如上图4.10和4.13，对于联合查询就是trngdsordershard01db.order_item_2020.order_id，对于等值查询就是const。

### rows

如果是全表扫描的方式，该值就代表该表的估计行数，如果使用索引就代表预计扫描的所有记录行数。

### filtered

此条件所过滤数据的百分比，如下所示：

```mysql
explain select * from supplier_p2p_order_2020 where supplier_order_id like '2%';
```

![4.14_explain_filtered](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.14_explain_filtered.png)

### Extra

Extra用来说明一些额外信息的，我们可以通过这些额外信息更准确的理解MySQL是如何执行的，主要有下面这些值：

+ **No tables used**：查询语句中没有from子句；

  ```mysql
  explain select 1;
  ```

  ![4.15_explain_extra_no_tables_used](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.15_explain_extra_no_tables_used.png)

+ **Impossible WHERE**：查询语句的where子句为false；

+ **No matching min/max row**：查询列表中有min/max聚集函数，但是并没有记录符合where子句中的搜索条件；

+ **Using index**：使用覆盖索引；

  ```mysql
  explain select order_id, order_item_id from product_customer where order_id=3057037620;
  ```

  ![4.16_explain_extra_using_index](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.16_explain_extra_using_index.png)

+ **Using index condition**：使用到了索引条件下推，如下所示例子中`supplier_order_id like '20%'`可以生成扫描区间，但是`supplier_order_id like '%1'`不能生成扫描区间，但是因为搜索条件列是一个，可以根据第二个搜索先做匹配，减少回表次数；

  ```mysql
  explain select * from supplier_p2p_order_2020 where supplier_order_id like '20%' and supplier_order_id like '%1';
  ```

  ![4.17_explain_extra_using_index_condition](https://raw.githubusercontent.com/maningning1/maningning1.github.io/main/images/mysql/4.17_explain_extra_using_index_condition.png)

+ **Using where**：当某个搜索条件需要在server层进行判断时；
+ **Using join buffer**：在连接查询的执行过程中，当被驱动表不能有效的利用索引加快访问速度时，MySQL会为其分配连接缓冲区（Join Buffer）；
+ **Zero limit**：limit子句参数为0；
+ **Using filesort**：排序使用到索引；
+ **Using temporary**：查询中使用到了内部临时表；