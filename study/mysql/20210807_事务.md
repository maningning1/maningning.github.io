# 事务

## 事务简介

### 事务的起源

对于一个经典的事务例子，A给B转账，对于数据库世界来说相当于执行了以下两条语句：

```mysql
# 为账号1扣款10元
update account set balance = balance - 10 where id = 1;
# 为账号2增加10元
update account set balance = balance + 10 where id = 2;
```

不管是先为转账方扣款还是先为收账方增加金额，语句均需要两条，此时如果在执行完第一条语句服务器突然断电，就会导致钱少（多）了，并且MySQL为了加快运行速度还提供了Buffer Pool，也可能会引发数据写入内存但还未加载进磁盘的情况。为了解决这种问题，数据库操作提出了以下几条规则：

#### 原子性（Atomicity）

对于前文的转账操作是一个不可分割的操作，要么失败要么成功，不应该存在中间状态，这种规则就称为原子性。

#### 隔离性（Isolation）

比如A给B进行了两次金额为5元的转账，那么不管顺序如何，最后A的账户肯定是少了10元，B的账户肯定是多了10元，其他状态不应该影响本次状态转换，这种规则称为隔离性，但是在数据库系统中可能出现如下情况：

![5.01_隔离性](D:\study_note\maningning1.github.io\images\mysql\5.01_隔离性.png)

#### 一致性（Consistency）

一致性是指数据库中数据全部符合现实世界的约束，AID是手段，C是结果。

#### 持久性（Durability）

持久性是指一个状态转换完成后，这个转换结果将会永久保留。

### 事务的概念

事务（transaction）是一个抽象概念，其表示需要保证原子性、隔离性、一致性和持久性的一个或多个数据库操作。数据库系统根据数据库操作将所执行的不同阶段划分为了下面几个状态：

+ **活动的（active）**：事务对应的数据库操作正在执行过程中时，我们就称该事务处于活动的状态；
+ **部分提交的（partially committed）**：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并没有刷新到磁盘时，我们就说该事务处于部分提交的状态；
+ **失败的（failed）**：当事务处于活动的状态或者部分提交的状态时，可能因为某些错误或人为停止当前事务的执行，就称当前事务处于失败的状态；
+ **中止的（aborted）**：比如事务在执行一部分后失败，需要对其回滚，就称该事务为中止的状态；
+ **提交的（committed）**：当一个处于部分提交的状态的事务将修改过的数据刷新到磁盘后，就称该事务处于提交的状态；

对于已提交的事务来说，该事务对数据库所做的修改将永久生效；对于处于中止状态的事务来说，该事务对数据库所做的所有修改将会被回滚到没执行该事务之前的状态。

![5.02_事务状态转换](D:\study_note\maningning1.github.io\images\mysql\5.02_事务状态转换.png)

## redo log

### 简介

我们知道InnoDB存储引擎是以页为单位来管理存储空间的，所以我们进行增删改查操作从本质上来说都是在访问页面，并且InnoDB提供了Buffer Pool来增加程序访问速度，但是这样就会导致如果只在Buffer Pool中修改了页面，在事务提交后发生故障导致内存中的数据丢失，这样就无法保证持久性，首先想到的就是直接把事务修改的页面刷新到磁盘，但是这样存在以下两个问题：

+ InnoDB以页为单位，每次必须要刷新一个页的数据，太浪费；
+ 一个事务包含多条语句，可能会修改多个页面，并且页面不相邻，需要进行大量的随机I/O；

基于此，InnoDB在每次事务提交时将每次修改的内容以日志的形式记录，这样即使系统崩溃了重启之后只需要按照日志内容重新更新数据页即可，这个日志称为redo log。redo log有下面这些好处：

+ 占用空间小；
+ 顺序写入磁盘，也就是使用的顺序I/O；

### redo log格式

InnoDB针对事务对数据库的不同修改场景定义了多种类型的redo log，但绝大部分redo log是下面这种通用结构：

![5.03_redo log格式](D:\study_note\maningning1.github.io\images\mysql\5.03_redo log格式.png)

+ type：redo log的类型；
+ space ID：表空间ID；
+ page number：页号；
+ data：具体内容；

#### 简单的redo log类型

在没有显示的定义主键时，InnoDB会为我们添加一个名为row_id的隐藏列作为主键，服务器在内存中维护了这个全局变量，并当这个全局变量的值为256的整数倍时会写入磁盘中，但其实这个写入操作是在Buffer Pool中完成的，所以需要用redo log进行记录，这种对页面的修改是极其简单的，仅需要记录在某个页面的某个偏移量处修改了几个字节，具体内容就好，这种简单的redo log称为物理日志，有如下几种类型：

+ **MLOG_1BYTE（type字段的值为1）**：表示在页面的某个偏移量处写入1字节的redo log类型；
+ **MLOG_2BYTE（type字段的值为2）**：表示在页面的某个偏移量处写入2字节的redo log类型；
+ **MLOG_4BYTE（type字段的值为4）**：表示在页面的某个偏移量处写入4字节的redo log类型；
+ **MLOG_8BYTE（type字段的值为8）**：表示在页面的某个偏移量处写入8字节的redo log类型；
+ **MLOG_WRITE_STRING（type字段的值为30）**：表示在页面的某个偏移量处写入一个字节序列；

![5.04_MLOG_XBYTE](D:\study_note\maningning1.github.io\images\mysql\5.04_MLOG_XBYTE.png)

MLOG_WRITE_STRING的len字段可以填充上1,2,4,8就可以表示其他几种类型，但InnoDB为了节省空间所以设计了其他类型。

![5.05_MLOG_WRITE_STRING](D:\study_note\maningning1.github.io\images\mysql\5.05_MLOG_WRITE_STRING.png)

#### 复杂的redo log类型

以一条insert语句为例，其可能对B+树有如下更新：

+ 表中包含多少个索引，就可能更新多少个B+树；
+ 针对一个B+树来说，除了叶子节点会更新，可能也会更新内节点，也可能会创建新的页面；

同时，除了需要更新实际存储的记录外，还需要更新数据页的其他属性：

+ 可能更新Page Directory的槽信息；
+ 可能更新Page Header中的各种统计信息；
+ 还可能更新上一条记录的记录头信息中的next_record属性；

正是因为插入一条记录到一个页面中需要更改的地方非常多，所以InnoDB采用将整个页面第一个被修改的字节到最后一个被修改的字节之间的所有数据当做一个redo log，这样就可以防止redo log过多，但是这样会导致第一个被修改的字节到最后一个被修改的字节间有很多没有修改过的数据，会导致空间的浪费，故InnoDB提出了以下几种redo log类型：

+ **MLOG_REC_INSERT（type字段的值为9）**：表示插入一条非紧凑行格式（REDUNDANT）时的redo log类型；
+ **MLOG_COMP_REC_INSERT（type字段的值为38）**：表示插入一条紧凑行格式（COMPACT/DYNAMIC/COMPRESSED）时的redo log类型；
+ **MLOG_COMP_REC_CREATE（type字段的值为58）**：表示创建一个存储紧凑行格式记录时的redo log类型；
+ **MLOG_COMP_REC_DELETE（type字段的值为42）**：表示删除一条存储紧凑行格式记录时的redo log类型；
+ **MLOG_COMP_LIST_START_DELETE（type字段的值为44）**：表示从某条给定记录开始删除页面中一系列使用紧凑行格式的记录时的redo log类型；
+ **MLOG_COMP_LIST_START_DELETE（type字段的值为43）**：表示删除页面中一系列使用紧凑行格式的记录直到此type为止时的redo log类型；
+ **MLOG_ZIP_PAGE_COMPRESS（type字段的值为51）**：表示在压缩一个数据页时的redo log类型；

这些类型的redo log包含了以下两层意思：

+ 物理层面：这些日志都指明了对哪个表空间的哪个页进行修改；
+ 逻辑层面：在系统崩溃后需要调用相关函数才能将页面恢复；